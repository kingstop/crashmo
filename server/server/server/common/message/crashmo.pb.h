// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: crashmo.proto

#ifndef PROTOBUF_crashmo_2eproto__INCLUDED
#define PROTOBUF_crashmo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace message {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_crashmo_2eproto();
void protobuf_AssignDesc_crashmo_2eproto();
void protobuf_ShutdownFile_crashmo_2eproto();

class SaveOfficeMapData;
class SaveIncompleteMap;
class SaveCompleteMap;
class CrashmoClientInit;

// ===================================================================

class SaveOfficeMapData : public ::google::protobuf::Message {
 public:
  SaveOfficeMapData();
  virtual ~SaveOfficeMapData();

  SaveOfficeMapData(const SaveOfficeMapData& from);

  inline SaveOfficeMapData& operator=(const SaveOfficeMapData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SaveOfficeMapData& default_instance();

  void Swap(SaveOfficeMapData* other);

  // implements Message ----------------------------------------------

  inline SaveOfficeMapData* New() const { return New(NULL); }

  SaveOfficeMapData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SaveOfficeMapData& from);
  void MergeFrom(const SaveOfficeMapData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SaveOfficeMapData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .message.CrashMapData map = 1;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 1;
  const ::message::CrashMapData& map() const;
  ::message::CrashMapData* mutable_map();
  ::message::CrashMapData* release_map();
  void set_allocated_map(::message::CrashMapData* map);

  // @@protoc_insertion_point(class_scope:message.SaveOfficeMapData)
 private:
  inline void set_has_map();
  inline void clear_has_map();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::message::CrashMapData* map_;
  friend void  protobuf_AddDesc_crashmo_2eproto();
  friend void protobuf_AssignDesc_crashmo_2eproto();
  friend void protobuf_ShutdownFile_crashmo_2eproto();

  void InitAsDefaultInstance();
  static SaveOfficeMapData* default_instance_;
};
// -------------------------------------------------------------------

class SaveIncompleteMap : public ::google::protobuf::Message {
 public:
  SaveIncompleteMap();
  virtual ~SaveIncompleteMap();

  SaveIncompleteMap(const SaveIncompleteMap& from);

  inline SaveIncompleteMap& operator=(const SaveIncompleteMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SaveIncompleteMap& default_instance();

  void Swap(SaveIncompleteMap* other);

  // implements Message ----------------------------------------------

  inline SaveIncompleteMap* New() const { return New(NULL); }

  SaveIncompleteMap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SaveIncompleteMap& from);
  void MergeFrom(const SaveIncompleteMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SaveIncompleteMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .message.CrashMapData map = 1;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 1;
  const ::message::CrashMapData& map() const;
  ::message::CrashMapData* mutable_map();
  ::message::CrashMapData* release_map();
  void set_allocated_map(::message::CrashMapData* map);

  // @@protoc_insertion_point(class_scope:message.SaveIncompleteMap)
 private:
  inline void set_has_map();
  inline void clear_has_map();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::message::CrashMapData* map_;
  friend void  protobuf_AddDesc_crashmo_2eproto();
  friend void protobuf_AssignDesc_crashmo_2eproto();
  friend void protobuf_ShutdownFile_crashmo_2eproto();

  void InitAsDefaultInstance();
  static SaveIncompleteMap* default_instance_;
};
// -------------------------------------------------------------------

class SaveCompleteMap : public ::google::protobuf::Message {
 public:
  SaveCompleteMap();
  virtual ~SaveCompleteMap();

  SaveCompleteMap(const SaveCompleteMap& from);

  inline SaveCompleteMap& operator=(const SaveCompleteMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SaveCompleteMap& default_instance();

  void Swap(SaveCompleteMap* other);

  // implements Message ----------------------------------------------

  inline SaveCompleteMap* New() const { return New(NULL); }

  SaveCompleteMap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SaveCompleteMap& from);
  void MergeFrom(const SaveCompleteMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SaveCompleteMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .message.CrashMapData map = 1;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 1;
  const ::message::CrashMapData& map() const;
  ::message::CrashMapData* mutable_map();
  ::message::CrashMapData* release_map();
  void set_allocated_map(::message::CrashMapData* map);

  // @@protoc_insertion_point(class_scope:message.SaveCompleteMap)
 private:
  inline void set_has_map();
  inline void clear_has_map();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::message::CrashMapData* map_;
  friend void  protobuf_AddDesc_crashmo_2eproto();
  friend void protobuf_AssignDesc_crashmo_2eproto();
  friend void protobuf_ShutdownFile_crashmo_2eproto();

  void InitAsDefaultInstance();
  static SaveCompleteMap* default_instance_;
};
// -------------------------------------------------------------------

class CrashmoClientInit : public ::google::protobuf::Message {
 public:
  CrashmoClientInit();
  virtual ~CrashmoClientInit();

  CrashmoClientInit(const CrashmoClientInit& from);

  inline CrashmoClientInit& operator=(const CrashmoClientInit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrashmoClientInit& default_instance();

  void Swap(CrashmoClientInit* other);

  // implements Message ----------------------------------------------

  inline CrashmoClientInit* New() const { return New(NULL); }

  CrashmoClientInit* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CrashmoClientInit& from);
  void MergeFrom(const CrashmoClientInit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CrashmoClientInit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .message.CrashPlayerInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::message::CrashPlayerInfo& info() const;
  ::message::CrashPlayerInfo* mutable_info();
  ::message::CrashPlayerInfo* release_info();
  void set_allocated_info(::message::CrashPlayerInfo* info);

  // @@protoc_insertion_point(class_scope:message.CrashmoClientInit)
 private:
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::message::CrashPlayerInfo* info_;
  friend void  protobuf_AddDesc_crashmo_2eproto();
  friend void protobuf_AssignDesc_crashmo_2eproto();
  friend void protobuf_ShutdownFile_crashmo_2eproto();

  void InitAsDefaultInstance();
  static CrashmoClientInit* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// SaveOfficeMapData

// required .message.CrashMapData map = 1;
inline bool SaveOfficeMapData::has_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SaveOfficeMapData::set_has_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SaveOfficeMapData::clear_has_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SaveOfficeMapData::clear_map() {
  if (map_ != NULL) map_->::message::CrashMapData::Clear();
  clear_has_map();
}
inline const ::message::CrashMapData& SaveOfficeMapData::map() const {
  // @@protoc_insertion_point(field_get:message.SaveOfficeMapData.map)
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::message::CrashMapData* SaveOfficeMapData::mutable_map() {
  set_has_map();
  if (map_ == NULL) {
    map_ = new ::message::CrashMapData;
  }
  // @@protoc_insertion_point(field_mutable:message.SaveOfficeMapData.map)
  return map_;
}
inline ::message::CrashMapData* SaveOfficeMapData::release_map() {
  clear_has_map();
  ::message::CrashMapData* temp = map_;
  map_ = NULL;
  return temp;
}
inline void SaveOfficeMapData::set_allocated_map(::message::CrashMapData* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
  // @@protoc_insertion_point(field_set_allocated:message.SaveOfficeMapData.map)
}

// -------------------------------------------------------------------

// SaveIncompleteMap

// required .message.CrashMapData map = 1;
inline bool SaveIncompleteMap::has_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SaveIncompleteMap::set_has_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SaveIncompleteMap::clear_has_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SaveIncompleteMap::clear_map() {
  if (map_ != NULL) map_->::message::CrashMapData::Clear();
  clear_has_map();
}
inline const ::message::CrashMapData& SaveIncompleteMap::map() const {
  // @@protoc_insertion_point(field_get:message.SaveIncompleteMap.map)
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::message::CrashMapData* SaveIncompleteMap::mutable_map() {
  set_has_map();
  if (map_ == NULL) {
    map_ = new ::message::CrashMapData;
  }
  // @@protoc_insertion_point(field_mutable:message.SaveIncompleteMap.map)
  return map_;
}
inline ::message::CrashMapData* SaveIncompleteMap::release_map() {
  clear_has_map();
  ::message::CrashMapData* temp = map_;
  map_ = NULL;
  return temp;
}
inline void SaveIncompleteMap::set_allocated_map(::message::CrashMapData* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
  // @@protoc_insertion_point(field_set_allocated:message.SaveIncompleteMap.map)
}

// -------------------------------------------------------------------

// SaveCompleteMap

// required .message.CrashMapData map = 1;
inline bool SaveCompleteMap::has_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SaveCompleteMap::set_has_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SaveCompleteMap::clear_has_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SaveCompleteMap::clear_map() {
  if (map_ != NULL) map_->::message::CrashMapData::Clear();
  clear_has_map();
}
inline const ::message::CrashMapData& SaveCompleteMap::map() const {
  // @@protoc_insertion_point(field_get:message.SaveCompleteMap.map)
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::message::CrashMapData* SaveCompleteMap::mutable_map() {
  set_has_map();
  if (map_ == NULL) {
    map_ = new ::message::CrashMapData;
  }
  // @@protoc_insertion_point(field_mutable:message.SaveCompleteMap.map)
  return map_;
}
inline ::message::CrashMapData* SaveCompleteMap::release_map() {
  clear_has_map();
  ::message::CrashMapData* temp = map_;
  map_ = NULL;
  return temp;
}
inline void SaveCompleteMap::set_allocated_map(::message::CrashMapData* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
  // @@protoc_insertion_point(field_set_allocated:message.SaveCompleteMap.map)
}

// -------------------------------------------------------------------

// CrashmoClientInit

// required .message.CrashPlayerInfo info = 1;
inline bool CrashmoClientInit::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrashmoClientInit::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrashmoClientInit::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CrashmoClientInit::clear_info() {
  if (info_ != NULL) info_->::message::CrashPlayerInfo::Clear();
  clear_has_info();
}
inline const ::message::CrashPlayerInfo& CrashmoClientInit::info() const {
  // @@protoc_insertion_point(field_get:message.CrashmoClientInit.info)
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::message::CrashPlayerInfo* CrashmoClientInit::mutable_info() {
  set_has_info();
  if (info_ == NULL) {
    info_ = new ::message::CrashPlayerInfo;
  }
  // @@protoc_insertion_point(field_mutable:message.CrashmoClientInit.info)
  return info_;
}
inline ::message::CrashPlayerInfo* CrashmoClientInit::release_info() {
  clear_has_info();
  ::message::CrashPlayerInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void CrashmoClientInit::set_allocated_info(::message::CrashPlayerInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
  // @@protoc_insertion_point(field_set_allocated:message.CrashmoClientInit.info)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_crashmo_2eproto__INCLUDED
